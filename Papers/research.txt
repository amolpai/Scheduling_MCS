HI-criticality modes-
	-> Fewer tasks
	-> Longer execution times
	-> Bound on high-criticality execution times is increased

LO-criticality modes-
	-> All execution times determined by low-criticality values
	-> All deadlines must be met


System not schedulable during criticality change

One scheduling algorithm-
	-> Both high and low criticality jobs are ordered by deadline
	-> Priorities assigned to each task from lowest to highest level
	-> At each level, the lowest priority task from the low criticality level checked. If it is not schedulable, then check next task. If none schedulable, then check lowest priority task from high criticality level. 
	
For any task, Ï„ i , first its LO-criticality response-time (R(LO)) is computed using LO-criticality parameters for all the tasks. A criticality switch must occur before this value if the task is to be impacted by the change, otherwise it will have completed execution. The worst-case response-time in the HI-criticality mode (R(HI)) is computed by noting that all LO-criticality tasks must be abandoned by time R(LO). The paper contains two methods for computing R(HI) 21, one involves a single upper bound, the other looks at all the possible critically change points before R(LO) and computes the worst-case.

AMC-rtb remains a good approximation for AMC-max. AMC-max becomes computationally expensive for increased criticality levels.

Priority does not change when there is a criticality change. (How does the criticality change?)

For changing priorities, assign three priorities for each task. One for each criticality level and one for transitioning between criticality modes.

The higher the criticality, the closer together the events are assumed to arrive and hence the smaller the T parameter.


SLACK SCHEDULING SCHEME
Low criticality jobs are run in the slack generated by high criticality jobs only using their low criticality execution budgets.

Problems
	-> Scheduling of sporadic tasks
	
	
	
PERIOD TRANSFORMATION

Splits a task with computation time C and period T into two tasks with computation time C/2 and period T/2.

Advantages
	-> High criticality tasks split using period transformation can have priority greater than low criticality tasks. 
	
Disadvantges
	-> Additional overhead due to increased number of context switches
	
For spliting, the programmer has to identify where in the code, the split should be made. Makes code transformation impractical. 


REAL TIME SYSTEMS
-> Weighted Round Robin approach
	--> Different jobs given different weights instead of giving each job equal time slice
	--> Each job gets time slice proportional to their weights


