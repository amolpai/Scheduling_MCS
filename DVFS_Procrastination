procrastination - shutting down processor to maximize idle duration by putting all jobs on other side.

Tradeoff between DVFS and procrastination. 
In procrastination, all remaining tasks execute at highest frequency available. Defer tasks till the end. 

Procrastination in multiple core

Implement procrastination with DVFS in unicore for now.
Procrastination - done when the processor idle time is greater than a threshold.

Implement for all tasks in LO mode and HI tasks in HI mode separately. Think about system change later. 

Look for DVFS papers in real time systems. 

Insert all jobs in ready queue at the timer expiry of kernel.

The timer expiry of kernel will be the latest deadline - WCET of jobs arrived before it.

Global queue for all low criticality tasks. Implement for more than 2 criticality levels.


--> Divide the tasks into two groups - low period and high period. Depending on the value of 2P-2E. If greater than shutdown threshold, it is high period, otherwise it is low period. In the two subgroups, impose all the criticality constraints applicable (every core should have atleast one task of each criticality level). Find the subset of cores to which all low period tasks can be allocated and if any more space is free, allocate high period tasks and then find the next subset to allocate the high period tasks. Subset of cores = ceil(utilisation of low period tasks).
--> When a core goes for shutdown, migrate all the tasks of this core to some other core. The tasks to be migrated are generally of criticality level 0 and 1. Calculate the procrastination interval after migrating these jobs. 

--> When a core is deciding to go for shutdown, first calculate the procrastination interval and decided whether the core can be shutdown or not.
    1. If the core cannot be shutdown, then schedule a job from the discarded queue.
    2. If the core can be shutdown, then first check with the non-shutdown cores and calculate the slack available with each core. 
        2.1 If any of the remanining cores has enough slack to accommodate the discarded job, let it handle it and go for shutdown.
        2.2 Else, check with the remaining shutdown cores and  check the procrastination interval for each. If the procrastination interval is long enough to accommodate the discarded job, let it handle it and go for shutdown.
        2.3 Else, handle the discarded job yourself and worry about the procrastination interval later.

        While calculating procrastionation_interval for remaining cores, allocate all the jobs to the core having the least procrastination interval. This will avoid messing with the procrastionation_interval of the other cores.
        


--> First try to allocate the discarded jobs allocated to this core in the ready queue. Then, check the discarded queue and check if any other jobs can be allocated or not. If the core is going for shutdown, don't accommodate any discarded jobs and let the other cores accommodate them.


Interesting things observed:
1. If no task is allocated to a core, should it accommodate the discarded jobs, execute it and go in shutdown again? No (DONE)
2. When there is a crit change, should a core which is in shutdown try to accommodate jobs from discarded queue? No (DONE)
3. When updating the job arrivals in the ready_queue, accommodate from the highest to lowest criticality_level. (DONE)
4. Due to shutdown, the discarded jobs that had arrived during the interval may miss their deadline. That is okay. (DONE)
5. When the core is going for shutdown, should the criticality of the system be reduced? (MAIN) (DONE)
6. When the decision time of arrival and completion is same, the priority is given to completion. At that time, it tries to insert jobs from discarded queue in ready queue and at the next decision point, will enter the arrival of next job. (DONE)
7. When there is a crit_change, should the procrastination intervals be re-calculated? Because the execution times were taken of a lower criticality level during calculation. (MAIN) (DONE)
8. During calculation of procrastination interval, we take the WCET of jobs and calculate the interval. Possibility of WCET getting exceeded due to which a job may miss its deadline. (MAIN) (DONE)
    Solution: Use the maximum WCET of each job instead of the WCET of current criticality level

1. Criticality of system will be reduced to zero when all the cores are idle. If any core is not idle, and it has jobs of only the lower criticality level, then decrease the criticality_level to the highest of all the jobs.
2. At criticality change of system, reclassify the cores into shutdown and non-shutdown cores. Calculate the procrastination interval for only shutdown cores.

Things to be discussed:
1. Energy parameters to be used.
    - Inserting and removing job from ready and discarded queue.
    - Preemption or scheduling a new job in core.
    - Shutdown and wakeup of core.
    - Criticality change of system.
    Every decision point, context switch, active and idle time, shutdown durations.
    Shutdown durations - will not have any static frequency power consumption.
2. When core wakes up after crit_change, it should find new interval for procrastination if no jobs available.
3. How to do DVFS?
4. Changing the allocation algorithm and using only one function for non-shutdown and shutdown tasks.
5. Should we calculate procrastionation_interval only for shutdown cores?
6. When we say we impose a limit on utilisation, is it excluding the exceptional tasks?
7. What all to include in proposed work? (No)
    - schedulability conditions for edf-vd?
    - overview of edf-vd?
    - procrastination algorithm used?
    - proof of 2P - 2E?
8. Complexity of scheduling and allocation algorithms.

Correctness proof of feasible schedule and schedule consumes less energy than normal.

DVFS algorithm:

Completion of job:
1. Find the procrastionation_interval from current time.
2. If the ready queue is empty, and the procrastionation_interval is greater than SDT, shutdown. Else, idle till next arrival point.
2. If the ready queue is not empty, and the active period is empty  then use the selector algorithm to find the frequency. 

Arrival of job:
1. If the arrival is discarded job, then recalculate the frequency.
2. If the procrastionation_interval has ended now, then recalculate the frequency. 

Wakeup of core:
1. Mark core frequency as MAX.

Criticality change of system:
1. After accommodating all discarded jobs, select_frequency again.

Selector algorithm:
1. Find active period of processor (include AET of discarded jobs).
2. Find idle duration after the active period. 
3. Find frequency closest to active period / active period + idle duration.

Problems:
1. Need to change the calculation of the active period. 
 - Instead of using the task's criticality level, use the next criticality level of processor. As the task cannot exceed the wcet of the next criticality level.

 To ensure that high criticality tasks dont miss deadline when they exceed their WCET, use the WCET one level above for calculations.
 As we are increasing the criticality level one by one, we can assume that any job will not exceed the WCET[curr_level + 1].

Algorithm 2:
 Arrival of a job:
 - If it is a discarded job, consider the job as a periodic job and find the frequency using schedulability conditions. 

 14, 376

Algorithm 3:
1. Accommodate the discarded jobs at periodic intervals rather than at completion of processor.
2. Execute all discarded jobs at max frequency.
3. Use active period calculation to determine the frequency for the rest of the jobs. 

Algorithm 4:
1. When a discarded job is scheduled, find the maximum slack available and calculate the frequency.
2. When ready queue is empty, calculate procrastination interval and based on that, either go for shutdown or accommodate discarded jobs.
3. During arrival/completion of job, calculate the frequency using dynamic utilization. Dynamic utilization is calculated using the utilizations of tasks present in the ready queue and the ones that will arrive in the future before the deadline of the currently executing job.
    The maximum jobs that will be considered is N. 

Points to consider:
1. should we use relative deadline for higher criticality utilisation?
2. should we consider partial utilisation for lower priority jobs in higher utilisation?
3. How to ensure that the dynamic utilisation is less than 1? Is it necessary? 
4. Is it necessary to decrease the criticality levels?

Observations:
1. The active time increased and the idle and shutdown times decreased. 
2. Using discrete frequency levels instead of continuous ones.