PROCRASTINATION SCHEDULING FOR MULTI-CRITICALITY SYSTEMS IN A MULTI-CORE ENVIRONMENT.

Directory Structure:
1) Codes: Contains the codes for various scheduling algorithms, discussed over time.

2) Evaluation: Contains the implementations for DPS, EDF-VD, EDF-VD with DJ and EDF with procrastination
    2.1) common: Contains the common functions for all the algorithms
        -> auxiliary_functions.c: Contains the printer functions and other helper functions
        -> check_functions.c: Contains the functions for checking the schedulability conditions
            -> x_factor_struct check_schedulability(task_set_struct *task_set, int core_no): 
                Given a taskset and the core, it checks whether the sub-taskset belonging to that core is schedulable or not.
                Return value: Updated x-factor for the core. If the core is not schedulable, then the x-factor is 0.
        -> data_structures.h: Contains the various data structures
        -> driver.c: The driver code, which starts the scheduling.
        -> functions.h: Contains the declaration of all functions in all the files. Grouped by the use of the function (auxiliary, check, scheduler, allocation etc)
        -> procrastination.c: Contains the function for calculating the procrastination interval
            -> double find_procrastination_interval(double curr_time, task_set_struct *task_set, int curr_crit_level, int core_no):
                Given the current time, current criticality level, taskset and core, it calculates the procrastination interval for all the tasks belonging to the core
                with criticality level greater than or equal to the current criticality level and the deadlines greater than current time.
                Return value: Procrastination interval
        -> queue.c: Contains various queue functions (insertion, deletion for ready queue, discarded queue)
        -> scheduling.c: Contains the scheduling functions
            -> decision_struct find_decision_point(task_set_struct *task_set, processor_struct *processor, double super_hyperperiod):
                Given the taskset, it finds the next closest decision point. The decision_struct contains the decision point, decision time and the core no.
                The next decision point is the minimum of arrival, completion, WCET_counter and timer_expiry of all tasks and cores.
                Return value: The next decision point
            -> double find_max_slack(task_set_struct *task_set, int crit_level, int core_no, double deadline, double curr_time, job_queue_struct *ready_queue):
                Given taskset, curr_crit_level, core no, deadline of discarded job and the current time, it finds the maximum slack available between current time
                and the deadline, considering the jobs in the ready queue and the jobs arriving in the future before the deadline.
                Return value: max slack
            -> void accommodate_discarded_jobs(job_queue_struct **ready_queue, job_queue_struct **discarded_queue, task_set_struct *task_set, int core_no, int curr_crit_level, double curr_time):
                Given the ready queue, discarded queue and taskset, it tries to move jobs from the ready queue to the discarded job by calculating the maximum slack for each discarded job.
                The discarded queue is sorted based on the deadline and criticality level (criticality level highest to lowest, deadline earliest to latest)
            -> void update_job_arrivals(job_queue_struct **ready_queue, job_queue_struct **discarded_queue, task_set_struct *task_set, int curr_crit_level, double curr_time, int core_no, core_struct *core, int algo, int timer_expiry):
                This function is responsible for updating the job arrival in the ready queue or discarded queue. If the job's criticality level is greater than curr_crit_level, then it adds it
                in ready queue. Otherwise, it calculates the max slack and decides whether to add it in ready queue or discarded queue
    2.2) Functions in DPS, EDF-VD, EDF-VD with DJ and EDF are same with different implementations:
        -> allocation_functions.c: Contains the functions for allocating the taskset to the core
            -> int allocate(task_set_struct *task_set, int task_number, processor_struct *processor, double total_util[][MAX_CRITICALITY_LEVELS], double MAX_UTIL[], int exceptional_task, int shutdown, int non_shutdown_cores, FILE* allocation_file):
                It is responsible for allocating the task with task_number to one of the cores. It starts from the 1st core and checks whether the core is schedulable if the task is allocated to the core. If it is, then it returns 1, else it moves on to next core. If no core is available, it returns 0.
                Return value: 1 if task is allocated, else 0
            -> int allocate_tasks_to_cores(task_set_struct *task_set, processor_struct *processor):
                It is responsible for dividing the taskset into exceptional, non-shutdown and shutdown tasks. Then, it starts allocation of exceptional tasks, followed by non-shutdown tasks and shutdown tasks. If for any task, the allocate function returns 0, this function prints "Insufficient cores" and exits.
        -> scheduler_functions.c: Contains the functions for scheduling the taskset.
            -> void schedule_taskset(task_set_struct *task_set, processor_struct *processor):
                Starts scheduling of taskset. The scheduling is done till the superhyperperiod of all tasks.
                1. The next decision point is found.
                2. If the decision point is ARRIVAL, then the jobs are updated in ready queue and next highest priority job is scheduled.
                3. If the decision point is COMPLETION, then the job is removed from ready queue.  
                    3.1: If the ready queue is empty, then procrastination interval is calculated. 
                        3.1.1: If PI > SDT, core is shutdown and next invocation time is set.
                        3.1.2: Else, core tries to accommodate discarded jobs
                    3.2: Else, highest priority job is scheduled.
                4. If the decision point is TIMER_EXPIRY, all jobs are updated in ready queue and highest priority job is scheduled.
                5. If the decision point is CRIT_CHANGE, all LO-criticality jobs are first inserted in discarded queue. Then, jobs are accommodated back from discarded queue to ready queue. 
                     This is done for all cores.
            MINOR CHANGES FOR EDF-VD, EDF-VD WITH DJ AND EDF WITH PROCRASTINATION
            -> For EDF-VD, TIMER_EXPIRY decision point is removed and accommodation of discarded jobs is removed
            -> For EDF-VD with DJ, TIMER_EXPIRY decision point is removed
            -> For EDF, accommodation of discarded jobs is removed

3) create_taskset.c: Contains the functions for creating taskset.

4) create_times.c: Contains the functions for finding execution times of all jobs of all tasks. This is the execution time that is used during scheduling.

5) commands.sh:
        -> Creates the taskset - input_mcs.txt for DPS, EDF-VD and input_rts.txt for EDF
        -> Creates input_times.txt that contains execution times of all jobs of all tasks.
        -> Starts scheduling of all algorithms
        -> Moves the statistics of all algorithms to the parent folder. 

TO RUN ALL ALGORITHMS, JUST RUN THE COMMAND: ./commands.sh
TO RUN INDIVIDUAL ALGORITHMS, FIRST CREATE THE TASKSET FILE AND TIMES FILE USING create_taskset.c AND create_times.c AND THEN EXECUTE COMMAND: make FROM RESPECTIVE DIRECTORY.